install.packages(alr4)
install.packages('alr4')
install.packages('ggplot2')
install.packages('es1017')
install.packages('e1071')
install.packages('magritter')
install.packages('magrittr')
install.packages('leflet')
install.packages('leaflet')
install.packages('readxl')
install.packages('dplyr')
library(help=e1071)
#get current work directory
getwd()
#getting help
#The simplest way to get help in R is to click on the Help button on the toolbar
#if you know the name of the function you want help with, you just type a question mark ? at the command line prompt followed by the
#name of the function.
help(solve)
?solve
?read.table
#Sometimes you cannot remember the precise name of the function, but you know the subject on which
#you want help (e.g. data input in this case). Use the help.search function (without a question mark) with
#your query in double quotes like this
help.search("data input")
#Sometimes you cannot remember the precise name of the function, but you know the subject on which
#you want help (e.g. data input in this case). Use the help.search function (without a question mark) with
#your query in double quotes like this
help.search("data input")
#while apropos returns a character vector giving the names of all objects in the search list that match your
#(potentially partial) enquiry
apropos("lm")
#Other useful functions are find and apropos. The find function tells you what package something
#is in:
find("lowess")
#Other useful functions are find and apropos. The find function tells you what package something
#is in:
find("corr")
#Other useful functions are find and apropos. The find function tells you what package something
#is in:
find("cor")
#Other useful functions are find and apropos. The find function tells you what package something
#is in:
find("cov")
#Simple calculations: You can simply use R as a calculator
log(50)
5+3
#Multiple expressions can be placed in single line but have to be
# separated by semi-colons
log(20); 3*35; 5+2
#Assignment operations
#Variable assignment is a very easy task in R. There are three important things
# to keep in mind
# Variable names are case sensitive
# Variable names cannot begin with numbers
# Variable names cannot contain blank spaces
x <- 5
y = 5
print(x)
print(y)
#[1] indicates that x and y are vectors and 5 is the first element of the vector
x <- 1:50
x
#Sequences
0:20
20:6
seq(0,8,0.2)
sum(z=1:50)
z
sum(z=1:50)
z
sum(ab <- 1:50)
ab
a <- 4
a
str <- "abc"
str
boolean <- TRUE
boolean
a+str
a+boolean
str+boolean
#Type conversion
x <- "2.5"
class(x)
as.numeric(x)+a
#To identify the type of any object or structure, use class function
class(str)
x <- c(1, 0.5, 4)
x
y <- c("a","b","c")
y
z <- vector("numeric",length=50)
z
help(vector)
y <- c(2.4,"c")
y
#To find the class of a vector, use class function
class(y)
#Length of a vector
length(y)
#This representation of data in a vector allows you to ask mathematical questions easily
mean(x)
max(x)
quantile(x)
#Generating repeat
rep(4,9)
rep(1:7,10)
rep(1:7,each=3)
#What happens in this case?
rep(1:4,1:4)
#What happens in this case?
rep(1:4,1:4)
#Vector Arithematic. You can perform the arithematic operations on vectors in a
# manner similar to variable operations. Here, the operations are performed on
#each corresponding elements
x <- c(1, 0.5, 4)
x
y <- c(5,3,2)
y
x+y
#What happens in this case?
x <- c(1, 0.5, 4)
x
y <- c(5,3,2,1)
y
x+y
#What about this case?
x <- c(1, 0.5, 4)
x
y <- c(5,3,2,1,2,4)
y
x+y
a <- c(1,3,2,4,5,2,4,2,6,4,5,3)
a
#Extract individual elements of a vector
a[1]
#Access multiple values of a vector
b <- a[c(1,4)]
b
d <- a[1:4]
#Drop values from a vector
d[-1]
#Drop values from a vector
d[-1]
d <- a[1:4]
d
#Drop values from a vector
d[-1]
#Drop values from a vector
d[-1]
a >3
a/5
#Let us say that you want to select subset of a vector based on a condition.
anyvector <- a>3
a[anyvector]
x <- 1:30
x[x>5]
counts <- rnbinom(10000,mu=0.92,size=1.1)
counts[1:30]
table(counts)
#Column bind and row bind for matrices
x<- 1:6
x
y <- 12:17
y
cbind(x,y)
rbind(x,y)
#What happens in this case?
x<- 1:5
x
y <- 12:17
y
cbind(x,y)
rbind(x,y)
gender <- factor(c("female", "male", "female", "male", "female"))
class(gender)
mode(gender)
x <- factor(c("yes","no","maybe","yes","no"))
x
unclass(x)
#Tabular data is read into a type of data structure known as data frame.
#All variables in a data frame are stored as separate columns
#Different from matrix in the sense that each column can be of a different type
#Almost always, when you import data from an external data source, you import
# it using a data frame
x <- data.frame(col1=1:20, col2 = c(T, F, F, T))
x
nrow(x)
ncol(x)
#Check structure of a data frame
str(x)
#Element selection operations are similar to what we have for matrics
x[1]
x[1,1]
x[,2]
x[2:5,1]
#There is also one more operator $ for selecting specific columns of a dataframe
x$col1
#What in this case?
x$1
subset(x,subset=1)
square.it(5)
setwd('/Users/dks/AMPBA/Probability & Statistics in R/Session3/')
smsData <- load.csv('sms_spam.csv')
smsData <- read.csv('sms_spam.csv')
smsData
str(smsData)
dim(smsData)
smsData.summary()
smsData.summary
smsData.summary()
smsData.describe()
smsData.info()
smsData$1
print(smsData$col1)
str(smsData)
spam <- subset(smsData,type='spam')
ham <- subset(smsData,type='ham')
spam.count()
count(spam)
len(spam)
length(spam)
count.fields(spam)
length(spam)
str(spam)
str(spam)
str(ham)
spam <- subset(smsData,type=='spam')
ham <- subset(smsData,type=='ham')
str(spam)
str(ham)
smsData <- read.csv('sms_spam.csv',stringsAsFactors = FALSE)
smsData
install.packages('dplyr')
str(smsData)
smsData['type'==='spam']
smsData['type'=='spam']
smsData[$type=='spam']
smsData['$type'=='spam']
smsData[type=='spam']
smsData[type='spam']
smsData[smsData$type=='spam']
colnames(smsData)
smsData[smsData$type=='spam',]
spam <- smsData[smsData$type=='spam',]
ham <- smsData[smsData$type=='ham',]
str(spam)
str(ham)
colnames(smsData)
table(smsData)
table(smsData$type)
table(smsData$text)
80/(80+9.6*99)
0.008/(0.008+0.0095)
0.008/(0.008+0.095)
(80*1/100*100)/((80*1/100*100)+(9.6*99/(100*100)))
(80*1/100*100)/((80*1/(100*100))+(9.6*99/(100*100)))
(80*1/(100*100))/((80*1/(100*100))+(9.6*99/(100*100)))
#Manual approach
cricketerdata <- read.csv("cricketer.csv")
#Manual approach
setwd('~/AMPBA/Probability & Statistics in R/Session4/')
cricketerdata <- read.csv("cricketer.csv")
is_cricketer <- subset(cricketerdata, Cricketer=="YES")
not_cricketer <- subset(cricketerdata, Cricketer=="NO")
prob.cricketer <- colSums(is_cricketer[,1:3]== "YES")/dim(is_cricketer)[1]
prob.notcricketer <- colSums(not_cricketer[,1:3]== "NO")/dim(not_cricketer)[1]
prob.cricketer
prob.notcricketer
str(cricketerdata)
nrow(is_cricketer)
prob.cricAlone=nrow(is_cricketer)/nrow(cricketerdata)
prob.cricAlone
nrow(cricketerdata)
library(e1071)
classify <- naiveBayes(cricketerdata[1:10,1:3],cricketerdata[1:10,4])
classify
y=predict(classify, cricketerdata[11,1:3])
y
cricketerdata <- read.csv("cricketer.csv",stringsAsFactors = TRUE)
classify <- naiveBayes(cricketerdata[1:10,1:3],cricketerdata[1:10,4])
classify
y=predict(classify, cricketerdata[11,1:3])
y
y
classify <- naiveBayes(cricketerdata[1:10,1:3],cricketerdata[1:10,4])
classify
prob.cricketer
r
prob.notcricketer
cricketerdata[,11]
cricketerdata[11]
cricketerdata[11,]
cricketerdata[11,]*prob.cricketer
prob.cricketer
cricketerdata[11,]
x=factor(['YES','NO'])
x=factor(c('YES','NO'))
x
cricketerdata[11,1]
cricketerdata[11,1]
cricketerdata[11,1]
cricketerdata[11,1][1]
cricketerdata[11,1][,1]
cricketerdata[11,1][1,]
cricketerdata[11,1]
cricketerdata[[11,1]]
cricketerdata[11,1]
cricketerdata[11,'NO']
cricketerdata[11,'YES']
cricketerdata[11,]
prob.cricketer
cricketerdata[11,]*classifier[cricketerdata[11,]]
??dbinom
library(MASS)
Boston
dim(Boston)
str(Boston)
cov(Boston)
cor(Boston)
summary(Boston)
??Boston
??USArrests
??Boston
